# Lab: file system 

# 源码分析 
- xv6中inode分为`in-memory copy of an inode` 和 `disk inode`，其中系统中被激活的inode最多可以有`NINODE`个，维护在itable中，每个inode中的`inum`即指示了其在物理硬盘中的存储位置（sb.inodestart）。
- ialloc可以在物理硬盘中分配一个inode，iget通过inum访问物理硬盘中的inode，返回其`in-memory copy`；
- ilock即给传入的inode上锁，同时检查该inode有效性，若无效则同时从物理硬盘中读取出该inode；iunlock仅仅释放对应inode的锁；iput每次可以使该in-memory inode 的引用减一，当一个inode的引用减为0后，会被视为被memory抛弃，当在iput中某个inode的nlink和ref同时减到0时，其物理存储空间将被释放，一个通过sys_open创建的文件，最初创建的inode中nlink被置1，也就是最少含有一个自己对自己的链接。
- namei和nameiparent都是通过路径名来返回对应的inode，其底层都是对namex的调用，但后者返回的是传入路径的上一级inode，例如`path= a/b/c`，前者得到c的inode，后者得到b的inode；namex中通过逐层解析路径path(用`'/'`来分隔)，来得到需要的inode。 
- inode结构体中的addrs就是对应文件的数据块的索引，每一个数据块大小为1024B，每条索引大小为32bit，故每个数据块可以包含1024/4=256条索引，即一级索引块可以索引256个数据块。
- 通过sys_open()观察到，从inode到用户态可用的文件描述符中还有一层`file`的抽象，每个进程文件描述符的编号也是根据该进程file的数量来衡量的，其中file中的ip字段则指向了其对应的inode。

## Large files 
### 内容分析 
xv6目前的文件系统中，每个文件最大的大小被限制为268个块(12+256)，其中包括12个直接索引块和1个一级间接索引块
- 任务目的是减少一个直接索引块，将其中一个一级索引块改为二级索引块，使得xv6支持最大文件大小为(11+256+256*256) 

### 设计方法 
- 首先修改`fs.h`中关于索引块的宏定义，具体即减少一个直接索引块，增加一个二级间接索引块 
- 之后修改fs.c中的`bmap`函数，因为增加了最大块的索引，故在原来的一级索引后增加在二级索引中寻找对应块号地址的代码；其中定义`NINDIRECT`为一个单独的数据块包含索引的条数，根据寻找的块号bn，`bn/NINDIRECT`得到一级目录中的索引号，`bn%NINDIRECT`得到二级目录中的索引号即可得到最终寻址 
- 在`itrunc`函数中增加与上类似的代码，释放数据块 

## Symbolic links 
### 内容分析 
- 在xv6中增加软连接系统调用，即一种特殊的文件类型，其指向另外一个文件 
- 考虑将所指向文件的路径名保存到创建文件的数据块中，当使用open打开该类型的文件时，增加相关跟踪代码，返回指向的目标文件 
- 当以`O_NOFOLLOW`的方式使用open打开该类型文件时，不跟踪到目标文件 

### 设计方法
- 增加一个系统调用`sys_symlink` 
- 在`fcntl.h`,`stat.h`中声明`O_NOFOLLOW`和`T_SYMLINK`，后者指代软连接文件类型 
- 在`sysfile.c`中增加该系统调用代码，使用`create`函数创建软连接文件对应的inode结构，其返回一个带锁的inode结构体指针，后将目标文件的路径通过`writei()`写入该软连接文件的数据块中(无需判断目标文件路径是否有效) 
- 调用`iunlockput()`释放inode的锁，该函数是`iunlock()`和`iput()`的组合, 前者即释放inode的锁; 而后者是减少一个inode的引用，同时上述所有操作均需要套在`begin_op()` 和 `end_op()`中 
- 修改`sys_open()`函数，增加处理软连接文件的相关代码，即当`omode`没有包含`O_NOFOLLOW`且文件类型是`T_SYMLINK`时，从当前文件数据块中读出目标文件的路径，调用`namei()`获得目标路径对应文件的inode 
- 同时，软连接可能存在循环链接的情况，使用实验指导介绍的方法近似解决该问题：对一个链最多追踪10次，超过该次数追踪到的仍然是软连接文件时判定为成环，错误退出 

### 不好的实验设计 
最初我的想法是直接将目标文件的inode存到软连接文件的数据块中，并没有想到可以直接存路径，通过`namei()`来直接获得inode。前者的设计方法有诸多限制，比如目标文件必须存在，否则自然无法获得对应的inode，在`open`中进行追踪时同样是一个问题。
