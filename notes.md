## 1.回顾页表
对页表映射物理内存的修正：**页表的顺序是有规律的**，同一个页（虚拟内存）的pte连续在一起，对应映射到物理内存的页上。
除了内核以外，所有使用到`mappages`的地方size都是`PGSIZE`，内核中只有在booting的时候，`kvmmap`可以自定义大小。
所以每次使用`mappages`时，va应该是需要被PGROUNDDOWN(va)，确保从当前页最低开始。
例子：
PTE pa
0   0
1   1
2   2
3   3
4   4
5   5
6   6
7   7
8   8
假设一个页单位大小为3，其中pa有3个页：(0,1,2)(3,4,5)(6,7,8)，不妨编号为q,k,v
某一个虚拟内存页开始地址为2，映射到第v个物理页，那么就有2--6,3--7,4--8这样的关系
物理内存每次分配映射必须是以页为单位进行
而不存在：PTE(2)--6，PTE(3)--5；PTE(2)是v号物理页的开始，代表虚拟地址2是某一个页的最低地址，下一个紧跟该虚拟地址（2）的下一个地址也必然是同一个物理页，故**页表的顺序是有规律的** 

**上述部分即为页表每个pte对应的都是一个物理页**，对应该pte的虚拟地址为某个页的最低地址，物理页内的内存是连续的，对应虚拟地址最低若干位的偏移（这部分没有参与页表映射），这若干位就是一个物理页的大小。但因为页表中的映射都是一个页的最低位的映射，所以要将当前虚拟地址进行`PGROUNDDOWN(va)`。 

## 2.COW-fork()
在uvmcopy中，子进程只是创建对应的页表指向父进程物理地址即可，其中需要清空PTE_W
但有一个判断条件是原本PTE_W需要为1，不能少，否则原本可能映射的就只是只读的内容(.text)，但因为COW-fork对page-fault的机制，会将其复制到一个标记为可读写的新物理内存，发生意料之外的错误。